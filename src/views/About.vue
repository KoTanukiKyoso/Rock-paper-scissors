<template class="primary">
  <text-page :contents="contents" :title="title"></text-page>
</template>

<script>

import TextPage from "@/components/TextPage";
export default {
  name: 'Top',
  components: {
    TextPage

  },
  data: () => ({
    title: {
      main: "ABOUT",
      sub: "本システムについて"
    },
    contents: [
      {
        title: "目的",
        text: `本システムは佐賀大学生の授業での使用，兼システム制作の勉強を目的として，佐賀大学の学生によって作成されました．`
      },
      {
        title: "用途",
        text: `本システムはオンラインでじゃんけんをする為のシステムです．遠く離れた人と，また１対多での大人数でのじゃんけんが可能です．`
      },
      {
        title: "開発環境",
        text: `OS：Windows10
        ブラウザ：Google Chrome
        IDE：PHP Storm
        言語：HTML，JavaScript，CSS，SASS（Scss）`
      },
      {
        title: "使用した主な技術，主要プラットフォーム等",
        text: `Vue Cli, Vue Router, Vue UI, Vuetify, Firebase Authentication, Firebase Cloud Firestore, NPM, FontAwesome, PWA`
      },
      {
        title: "制作期間，感想",
        text: `制作期間：2週間
2020/12/13
はっきり言ってもっと手っ取り早く完成する予定でした，3日くらい．シンプルな構造にしてGitHubで公開して後輩の参考にでもなればと思ってましたが，出来上がってみると内容は複雑の極み．
自分自身でも全体の把握ができてません．コンポーネント，つまり主要に記述したところでだけで80KBあります．スペース等無しで5万文字超えてますね多分．
ああ，勿論今書いてるこの辺は含みません．
このくらいのサイズになってくると自分でも全体が把握できません．そうなると全体を想定して，部分的に切り分けて，切り分けた部品を実装して，もう一度全体を見ながらくみ上げるといった作業になります．
作業効率は圧倒的に下がります．
<br>
さて，本題です．
今回新しく「Vue Cli, Vue Router, Vue UI, Vuetify, Firebase Cloud Firestore」使いました．
感想ですが，かなり注意が必要な印象です．
<br>
・Vuexを使わなかった話
シンプルなアプリにはVuexが向かないとの情報で，今回敢えてVuexに挑戦しなかったのですが，このくらいのアプリケーションには必須だと感じました．
Vue Cliのコンポーネントどうしが疎結合過ぎて，情報の共有難易度が非常に高いというか，私の挑戦した感じではほぼ無理です．
一番困ったのはAuthenticationのuidの浸透です．uid自体はVue.prototypeの中に格納することで実質的なグローバル変数にできましたが，そのuid取得イベントがどこからもホックできませんでした．
結果的に，ログイン処理が完了するまで0.5秒おきに変数を確認するという荒業が必要になりました．
<br>
・Vuetifyの話
初めてここまでデザインフレームワークと向き合った気がします．
これまでいくつかのデザインフレームワークに挑戦してきましたが，正直単純なフレームワークはCSS等が書けるなら邪魔なだけだと思ってます．
また，CDNの場合は特にデザインフレームワークが重く，ユーザビリティ的な意味でもデザインフレームワークは避けている部分がありました．
一方，Vuetifyがそういうわけにいかなかったのは，Vuetifyがコンポーネントを扱えるという部分があるからです．
これまでの単にデザインを整えるものにとどまらず，HTMLやスクリプトの連動ができ，かつパーツとして継承するような使用ができるため，これまでのデザインフレームワークとは一線を画すものです．
当然，他の大きなデザインフレームワークがある程度スクリプトレベルで内包していることを理解したうえで，Vuetifyのようなデザインフレームワークには将来性を感じます．
で，当のVuetifyですが，正直使い勝手はまあまあという感じです．
ドキュメントや不具合を含めて，本当に便利になるにはもう少し時間がかかると思いました．結構粗が目立ちます．
<br>
・Firestoreの話
Firestoreと略します．こいつは結構面白くて曲者です．
曲者な点ですが，結構あって，まずサーバがないので処理の主体がいません．
じゃんけんには少なくとも2人のユーザが必要です．例えば2人の手が出そろって1回戦が終了したとき，次の対決に進む際に，データベース上の何回戦かというデータを書き換える必要があります．
何故，何回戦かを記録する必要があるのか，それはウェブアプリケーションという特性上，ウェブブラウザを閉じるといった動作により，あらゆるデータは破棄されるからです．
ウェブアプリケーションでは基本的に，あらゆるデータをデータベースに保存することを強いられます．
で，サーバがあればその作業はサーバに任せることができますが，サーバがないため，ユーザがその処理をする必要があります．
ところが，1回戦が終了して2回戦に進める際，じゃんけんをした2人が1ずつ増やすことで，2回戦を飛ばして3回戦になってしまいます．
そこでまず，じゃんけんをする際に親と子を決め，親のみがじゃんけんの対戦回数を増やすようにする必要があります．
でで，ここでまた問題が発生します．親がじゃんけんの手を出した後ブラウザを閉じたとします．その後遅れて子が手を出します．
どうなるでしょうか，処理をするはずの親がいません．ウェブアプリでは往々にしてそういうことが発生します．
結局今回は，次の対戦に進む際に親にのみ「次の対戦に進む」ボタンを表示して押させるようにして解決しました．ボタンを押したということは必ず親が接続しているということです．
これで処理はうまくいく一方，逐一ユーザにボタンを押してもらうなどの処理を挟める必要があり，全体のテンポとしては悪く，また考えるべき処理や状態は格段に増えます．
<br>
次の厄介な点ですが，更新タイミングが保証されないという点があります．
サーバがある場合，例えば初期表示に必要なデータは全てまとめてDBから取得し，或いは足りないデータは補完し，クライアントに返却することができます．
一方，Firestoreでデータをリッスンしている場合，いつ何時どのデータが変更されるか，またどのデータがどの順番で取得されるかは基本的にわかりません．
じゃんけんの処理をしている最中に対戦相手が退出する，というようなことは平気で起こります．
サーバがあれば，少なくともクライアントから明示的に，退出したメンバーがいないか問い合わせない限り，退出したという情報を得ることはありません．
その結果，あらゆる変数がnullやundefinedである可能性を考慮する必要があります．それが単純な変数であればさほど手間でもありませんが，例えば「room.children.result[1].hand」等のような変数の場合，コードは
if(!room || !room.children || !room.children.result || ........)
という実にあほらしく長く機能に関係のない処理を毎度記述する羽目になります．
当然工夫次第である程度対処できる部分はありますが，とはいえ，どちらにせよ非常に作業の難易度が上がります．
Firestoreのリアルタイム性は便利ではありますがかなり危険性も内包しているといえます．
<br>
面白い点，調べた感じ，FirestoreはWebSocketを使用してリアルタイムな更新を実現しているようです．
副次的ですが，これが非常に便利です．最近はそう難しくないとはいえ，WebSocketを利用した双方向通信は正直実装めんどいです．
特に，安定させるのは至難です．
Firestoreのリアルタイム性を利用すれば，チャットやSNS，オンラインカードゲーム，ボードゲーム等の実装がはるかに簡単になると思います．
<br>

・全体の話
正直今までgulpとかその辺りで開発をしてきたので，npmなんかを中心にガンガンツールを入れて開発するのは非常に便利でいいと思いました．
とはいえ，それは将来を見越したうえでの話で，今回に限って言えば学習コストが高く難儀しました．
今までただ書けばよかったタイトルやdescriptionなんかも設定をする場所があったり動的に適用したりと，一度経験すれば楽だけど，，，
みたいな内容はいくらでもあります．
このプロジェクトはGitHubで公開してます．ごちゃごちゃしてますがまあ，参考になれば．
あ，Vuexは使ってね．
`
      },
    ]
  }),
  methods: {
    alert: (msg) => {
      alert(msg)
    },
  }
}
</script>
